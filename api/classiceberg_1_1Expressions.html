<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iceberg-cpp: iceberg::Expressions Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">iceberg-cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>iceberg</b></li><li class="navelem"><a class="el" href="classiceberg_1_1Expressions.html">Expressions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classiceberg_1_1Expressions-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">iceberg::Expressions Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Fluent APIs to create expressions.  
 <a href="classiceberg_1_1Expressions.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="expressions_8h_source.html">expressions.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad5129434b9a0e45e3fd3ffd53f5a3a40" id="r_ad5129434b9a0e45e3fd3ffd53f5a3a40"><td class="memTemplParams" colspan="2"><a id="ad5129434b9a0e45e3fd3ffd53f5a3a40" name="ad5129434b9a0e45e3fd3ffd53f5a3a40"></a>
template&lt;typename... Args&gt; <br />
requires std::conjunction_v&lt;std::is_same&lt;Args, std::shared_ptr&lt;<a class="el" href="classiceberg_1_1Expression.html">Expression</a>&gt;&gt;...&gt;</td></tr>
<tr class="memitem:ad5129434b9a0e45e3fd3ffd53f5a3a40"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>And</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt; left, std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt; right, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad5129434b9a0e45e3fd3ffd53f5a3a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an AND expression. <br /></td></tr>
<tr class="separator:ad5129434b9a0e45e3fd3ffd53f5a3a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f02015ae774f2ee14bcb7dfba2c287" id="r_ab6f02015ae774f2ee14bcb7dfba2c287"><td class="memTemplParams" colspan="2"><a id="ab6f02015ae774f2ee14bcb7dfba2c287" name="ab6f02015ae774f2ee14bcb7dfba2c287"></a>
template&lt;typename... Args&gt; <br />
requires std::conjunction_v&lt;std::is_same&lt;Args, std::shared_ptr&lt;<a class="el" href="classiceberg_1_1Expression.html">Expression</a>&gt;&gt;...&gt;</td></tr>
<tr class="memitem:ab6f02015ae774f2ee14bcb7dfba2c287"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Or</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt; left, std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt; right, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab6f02015ae774f2ee14bcb7dfba2c287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OR expression. <br /></td></tr>
<tr class="separator:ab6f02015ae774f2ee14bcb7dfba2c287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19757ac2b0dcf6e0b3acbb861b934e5e" id="r_a19757ac2b0dcf6e0b3acbb861b934e5e"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiceberg_1_1Expressions.html#a19757ac2b0dcf6e0b3acbb861b934e5e">Not</a> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt; child)</td></tr>
<tr class="memdesc:a19757ac2b0dcf6e0b3acbb861b934e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT expression.  <br /></td></tr>
<tr class="separator:a19757ac2b0dcf6e0b3acbb861b934e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3794ab614f6d31e8ca375fc2cb461868" id="r_a3794ab614f6d31e8ca375fc2cb461868"><td class="memItemLeft" align="right" valign="top"><a id="a3794ab614f6d31e8ca375fc2cb461868" name="a3794ab614f6d31e8ca375fc2cb461868"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTransform.html">UnboundTransform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Bucket</b> (std::string name, int32_t num_buckets)</td></tr>
<tr class="memdesc:a3794ab614f6d31e8ca375fc2cb461868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bucket transform term. <br /></td></tr>
<tr class="separator:a3794ab614f6d31e8ca375fc2cb461868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6066a65c379f703138e1b0abd8ed146d" id="r_a6066a65c379f703138e1b0abd8ed146d"><td class="memItemLeft" align="right" valign="top"><a id="a6066a65c379f703138e1b0abd8ed146d" name="a6066a65c379f703138e1b0abd8ed146d"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTransform.html">UnboundTransform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Year</b> (std::string name)</td></tr>
<tr class="memdesc:a6066a65c379f703138e1b0abd8ed146d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a year transform term. <br /></td></tr>
<tr class="separator:a6066a65c379f703138e1b0abd8ed146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5010427d1084bab3a514e4bfcdbfe1" id="r_aca5010427d1084bab3a514e4bfcdbfe1"><td class="memItemLeft" align="right" valign="top"><a id="aca5010427d1084bab3a514e4bfcdbfe1" name="aca5010427d1084bab3a514e4bfcdbfe1"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTransform.html">UnboundTransform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Month</b> (std::string name)</td></tr>
<tr class="memdesc:aca5010427d1084bab3a514e4bfcdbfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a month transform term. <br /></td></tr>
<tr class="separator:aca5010427d1084bab3a514e4bfcdbfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6b378fd8e69075a55ef3ec11e5e0f7" id="r_ada6b378fd8e69075a55ef3ec11e5e0f7"><td class="memItemLeft" align="right" valign="top"><a id="ada6b378fd8e69075a55ef3ec11e5e0f7" name="ada6b378fd8e69075a55ef3ec11e5e0f7"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTransform.html">UnboundTransform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Day</b> (std::string name)</td></tr>
<tr class="memdesc:ada6b378fd8e69075a55ef3ec11e5e0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a day transform term. <br /></td></tr>
<tr class="separator:ada6b378fd8e69075a55ef3ec11e5e0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a082b7916d62b3af9822e3f8db98b6" id="r_a68a082b7916d62b3af9822e3f8db98b6"><td class="memItemLeft" align="right" valign="top"><a id="a68a082b7916d62b3af9822e3f8db98b6" name="a68a082b7916d62b3af9822e3f8db98b6"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTransform.html">UnboundTransform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Hour</b> (std::string name)</td></tr>
<tr class="memdesc:a68a082b7916d62b3af9822e3f8db98b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an hour transform term. <br /></td></tr>
<tr class="separator:a68a082b7916d62b3af9822e3f8db98b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbb6b60bcaad6043a65b90a78bff09b" id="r_aadbb6b60bcaad6043a65b90a78bff09b"><td class="memItemLeft" align="right" valign="top"><a id="aadbb6b60bcaad6043a65b90a78bff09b" name="aadbb6b60bcaad6043a65b90a78bff09b"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTransform.html">UnboundTransform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Truncate</b> (std::string name, int32_t width)</td></tr>
<tr class="memdesc:aadbb6b60bcaad6043a65b90a78bff09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a truncate transform term. <br /></td></tr>
<tr class="separator:aadbb6b60bcaad6043a65b90a78bff09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c80fa9b7e8d7513e63696e8c0076a25" id="r_a0c80fa9b7e8d7513e63696e8c0076a25"><td class="memItemLeft" align="right" valign="top"><a id="a0c80fa9b7e8d7513e63696e8c0076a25" name="a0c80fa9b7e8d7513e63696e8c0076a25"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTransform.html">UnboundTransform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Transform</b> (std::string name, std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Transform.html">Transform</a> &gt; transform)</td></tr>
<tr class="memdesc:a0c80fa9b7e8d7513e63696e8c0076a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transform expression. <br /></td></tr>
<tr class="separator:a0c80fa9b7e8d7513e63696e8c0076a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48344e4a88a25023fd31546119b31ac" id="r_ac48344e4a88a25023fd31546119b31ac"><td class="memItemLeft" align="right" valign="top"><a id="ac48344e4a88a25023fd31546119b31ac" name="ac48344e4a88a25023fd31546119b31ac"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b> (std::string name)</td></tr>
<tr class="memdesc:ac48344e4a88a25023fd31546119b31ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a COUNT aggregate for a field name. <br /></td></tr>
<tr class="separator:ac48344e4a88a25023fd31546119b31ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328c82cdda89b0daa9c6bf05a1da0980" id="r_a328c82cdda89b0daa9c6bf05a1da0980"><td class="memItemLeft" align="right" valign="top"><a id="a328c82cdda89b0daa9c6bf05a1da0980" name="a328c82cdda89b0daa9c6bf05a1da0980"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt; expr)</td></tr>
<tr class="memdesc:a328c82cdda89b0daa9c6bf05a1da0980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a COUNT aggregate for an unbound term. <br /></td></tr>
<tr class="separator:a328c82cdda89b0daa9c6bf05a1da0980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31a1d7ee958d88faa2a7e67ff3b74ff" id="r_ad31a1d7ee958d88faa2a7e67ff3b74ff"><td class="memItemLeft" align="right" valign="top"><a id="ad31a1d7ee958d88faa2a7e67ff3b74ff" name="ad31a1d7ee958d88faa2a7e67ff3b74ff"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CountNull</b> (std::string name)</td></tr>
<tr class="memdesc:ad31a1d7ee958d88faa2a7e67ff3b74ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a COUNT_NULL aggregate for a field name. <br /></td></tr>
<tr class="separator:ad31a1d7ee958d88faa2a7e67ff3b74ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a147363fa3c91f399dae0f074500f9" id="r_a07a147363fa3c91f399dae0f074500f9"><td class="memItemLeft" align="right" valign="top"><a id="a07a147363fa3c91f399dae0f074500f9" name="a07a147363fa3c91f399dae0f074500f9"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CountNull</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt; expr)</td></tr>
<tr class="memdesc:a07a147363fa3c91f399dae0f074500f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a COUNT_NULL aggregate for an unbound term. <br /></td></tr>
<tr class="separator:a07a147363fa3c91f399dae0f074500f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fe79bac9d13e14f97b77634b555a5f" id="r_a40fe79bac9d13e14f97b77634b555a5f"><td class="memItemLeft" align="right" valign="top"><a id="a40fe79bac9d13e14f97b77634b555a5f" name="a40fe79bac9d13e14f97b77634b555a5f"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CountNotNull</b> (std::string name)</td></tr>
<tr class="memdesc:a40fe79bac9d13e14f97b77634b555a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a COUNT_NOT_NULL aggregate for a field name. <br /></td></tr>
<tr class="separator:a40fe79bac9d13e14f97b77634b555a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9ffa5f975ea353fef8ffa55a1cad8b" id="r_a6d9ffa5f975ea353fef8ffa55a1cad8b"><td class="memItemLeft" align="right" valign="top"><a id="a6d9ffa5f975ea353fef8ffa55a1cad8b" name="a6d9ffa5f975ea353fef8ffa55a1cad8b"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CountNotNull</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt; expr)</td></tr>
<tr class="memdesc:a6d9ffa5f975ea353fef8ffa55a1cad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a COUNT_NOT_NULL aggregate for an unbound term. <br /></td></tr>
<tr class="separator:a6d9ffa5f975ea353fef8ffa55a1cad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b19a7cca0670cd4933042a1fecba6b" id="r_ad2b19a7cca0670cd4933042a1fecba6b"><td class="memItemLeft" align="right" valign="top"><a id="ad2b19a7cca0670cd4933042a1fecba6b" name="ad2b19a7cca0670cd4933042a1fecba6b"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CountStar</b> ()</td></tr>
<tr class="memdesc:ad2b19a7cca0670cd4933042a1fecba6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a COUNT(*) aggregate. <br /></td></tr>
<tr class="separator:ad2b19a7cca0670cd4933042a1fecba6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76181bfd24b9c17e2b52f82d68c7908d" id="r_a76181bfd24b9c17e2b52f82d68c7908d"><td class="memItemLeft" align="right" valign="top"><a id="a76181bfd24b9c17e2b52f82d68c7908d" name="a76181bfd24b9c17e2b52f82d68c7908d"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Max</b> (std::string name)</td></tr>
<tr class="memdesc:a76181bfd24b9c17e2b52f82d68c7908d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a MAX aggregate for a field name. <br /></td></tr>
<tr class="separator:a76181bfd24b9c17e2b52f82d68c7908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac470b99828d4c9cd79f60033409af1f0" id="r_ac470b99828d4c9cd79f60033409af1f0"><td class="memItemLeft" align="right" valign="top"><a id="ac470b99828d4c9cd79f60033409af1f0" name="ac470b99828d4c9cd79f60033409af1f0"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Max</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt; expr)</td></tr>
<tr class="memdesc:ac470b99828d4c9cd79f60033409af1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a MAX aggregate for an unbound term. <br /></td></tr>
<tr class="separator:ac470b99828d4c9cd79f60033409af1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76805d74bc40350a0d92e5d6d95c556" id="r_ad76805d74bc40350a0d92e5d6d95c556"><td class="memItemLeft" align="right" valign="top"><a id="ad76805d74bc40350a0d92e5d6d95c556" name="ad76805d74bc40350a0d92e5d6d95c556"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundTransform.html">BoundTransform</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Max</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; <a class="el" href="classiceberg_1_1BoundTransform.html">BoundTransform</a> &gt; &gt; expr)</td></tr>
<tr class="memdesc:ad76805d74bc40350a0d92e5d6d95c556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a MAX aggregate for an unbound transform term. <br /></td></tr>
<tr class="separator:ad76805d74bc40350a0d92e5d6d95c556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260d57ba12656b8a65ee22a7d949b552" id="r_a260d57ba12656b8a65ee22a7d949b552"><td class="memItemLeft" align="right" valign="top"><a id="a260d57ba12656b8a65ee22a7d949b552" name="a260d57ba12656b8a65ee22a7d949b552"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Min</b> (std::string name)</td></tr>
<tr class="memdesc:a260d57ba12656b8a65ee22a7d949b552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a MIN aggregate for a field name. <br /></td></tr>
<tr class="separator:a260d57ba12656b8a65ee22a7d949b552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793dda1fb61f27cb5ccb5fecf7f644f9" id="r_a793dda1fb61f27cb5ccb5fecf7f644f9"><td class="memItemLeft" align="right" valign="top"><a id="a793dda1fb61f27cb5ccb5fecf7f644f9" name="a793dda1fb61f27cb5ccb5fecf7f644f9"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Min</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt; expr)</td></tr>
<tr class="memdesc:a793dda1fb61f27cb5ccb5fecf7f644f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a MIN aggregate for an unbound term. <br /></td></tr>
<tr class="separator:a793dda1fb61f27cb5ccb5fecf7f644f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa13eedbe6c5dfb50c5b6dfef3645ca2" id="r_afa13eedbe6c5dfb50c5b6dfef3645ca2"><td class="memItemLeft" align="right" valign="top"><a id="afa13eedbe6c5dfb50c5b6dfef3645ca2" name="afa13eedbe6c5dfb50c5b6dfef3645ca2"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundAggregateImpl.html">UnboundAggregateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundTransform.html">BoundTransform</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Min</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; <a class="el" href="classiceberg_1_1BoundTransform.html">BoundTransform</a> &gt; &gt; expr)</td></tr>
<tr class="memdesc:afa13eedbe6c5dfb50c5b6dfef3645ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a MIN aggregate for an unbound transform term. <br /></td></tr>
<tr class="separator:afa13eedbe6c5dfb50c5b6dfef3645ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a4b5dba2748af3fcb53d4434e290d" id="r_ac60a4b5dba2748af3fcb53d4434e290d"><td class="memItemLeft" align="right" valign="top"><a id="ac60a4b5dba2748af3fcb53d4434e290d" name="ac60a4b5dba2748af3fcb53d4434e290d"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IsNull</b> (std::string name)</td></tr>
<tr class="memdesc:ac60a4b5dba2748af3fcb53d4434e290d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IS NULL predicate for a field name. <br /></td></tr>
<tr class="separator:ac60a4b5dba2748af3fcb53d4434e290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90891efda7a0f4b1ff876effe0c9364" id="r_ad90891efda7a0f4b1ff876effe0c9364"><td class="memTemplParams" colspan="2"><a id="ad90891efda7a0f4b1ff876effe0c9364" name="ad90891efda7a0f4b1ff876effe0c9364"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:ad90891efda7a0f4b1ff876effe0c9364"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNull</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr)</td></tr>
<tr class="memdesc:ad90891efda7a0f4b1ff876effe0c9364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IS NULL predicate for an unbound term. <br /></td></tr>
<tr class="separator:ad90891efda7a0f4b1ff876effe0c9364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495669f931ea0ba80d4ed0581c53598d" id="r_a495669f931ea0ba80d4ed0581c53598d"><td class="memItemLeft" align="right" valign="top"><a id="a495669f931ea0ba80d4ed0581c53598d" name="a495669f931ea0ba80d4ed0581c53598d"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NotNull</b> (std::string name)</td></tr>
<tr class="memdesc:a495669f931ea0ba80d4ed0581c53598d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT NULL predicate for a field name. <br /></td></tr>
<tr class="separator:a495669f931ea0ba80d4ed0581c53598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a845a812dfed8e04455744195a49ba2" id="r_a1a845a812dfed8e04455744195a49ba2"><td class="memTemplParams" colspan="2"><a id="a1a845a812dfed8e04455744195a49ba2" name="a1a845a812dfed8e04455744195a49ba2"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a1a845a812dfed8e04455744195a49ba2"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NotNull</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr)</td></tr>
<tr class="memdesc:a1a845a812dfed8e04455744195a49ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT NULL predicate for an unbound term. <br /></td></tr>
<tr class="separator:a1a845a812dfed8e04455744195a49ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed115b3c4c0546727ee63a4d925cbda0" id="r_aed115b3c4c0546727ee63a4d925cbda0"><td class="memItemLeft" align="right" valign="top"><a id="aed115b3c4c0546727ee63a4d925cbda0" name="aed115b3c4c0546727ee63a4d925cbda0"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IsNaN</b> (std::string name)</td></tr>
<tr class="memdesc:aed115b3c4c0546727ee63a4d925cbda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IS NaN predicate for a field name. <br /></td></tr>
<tr class="separator:aed115b3c4c0546727ee63a4d925cbda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed7e94728431a5d6ed1951eecc2928" id="r_a7eed7e94728431a5d6ed1951eecc2928"><td class="memTemplParams" colspan="2"><a id="a7eed7e94728431a5d6ed1951eecc2928" name="a7eed7e94728431a5d6ed1951eecc2928"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a7eed7e94728431a5d6ed1951eecc2928"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNaN</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr)</td></tr>
<tr class="memdesc:a7eed7e94728431a5d6ed1951eecc2928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IS NaN predicate for an unbound term. <br /></td></tr>
<tr class="separator:a7eed7e94728431a5d6ed1951eecc2928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f4e5e0808914a3e2a7bf387109ca1" id="r_a323f4e5e0808914a3e2a7bf387109ca1"><td class="memItemLeft" align="right" valign="top"><a id="a323f4e5e0808914a3e2a7bf387109ca1" name="a323f4e5e0808914a3e2a7bf387109ca1"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NotNaN</b> (std::string name)</td></tr>
<tr class="memdesc:a323f4e5e0808914a3e2a7bf387109ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT NaN predicate for a field name. <br /></td></tr>
<tr class="separator:a323f4e5e0808914a3e2a7bf387109ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b3c1919f005602a04a323d03430154" id="r_a61b3c1919f005602a04a323d03430154"><td class="memTemplParams" colspan="2"><a id="a61b3c1919f005602a04a323d03430154" name="a61b3c1919f005602a04a323d03430154"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a61b3c1919f005602a04a323d03430154"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NotNaN</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr)</td></tr>
<tr class="memdesc:a61b3c1919f005602a04a323d03430154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT NaN predicate for an unbound term. <br /></td></tr>
<tr class="separator:a61b3c1919f005602a04a323d03430154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83afed36da05da0cb524800844b0974f" id="r_a83afed36da05da0cb524800844b0974f"><td class="memItemLeft" align="right" valign="top"><a id="a83afed36da05da0cb524800844b0974f" name="a83afed36da05da0cb524800844b0974f"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LessThan</b> (std::string name, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a83afed36da05da0cb524800844b0974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a less than predicate for a field name. <br /></td></tr>
<tr class="separator:a83afed36da05da0cb524800844b0974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00e0e79f35bbe29f6fb9e2ba8702225" id="r_ad00e0e79f35bbe29f6fb9e2ba8702225"><td class="memTemplParams" colspan="2"><a id="ad00e0e79f35bbe29f6fb9e2ba8702225" name="ad00e0e79f35bbe29f6fb9e2ba8702225"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:ad00e0e79f35bbe29f6fb9e2ba8702225"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LessThan</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:ad00e0e79f35bbe29f6fb9e2ba8702225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a less than predicate for an unbound term. <br /></td></tr>
<tr class="separator:ad00e0e79f35bbe29f6fb9e2ba8702225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cb4a5f3aff3811cd5a2ed9916a5686" id="r_a18cb4a5f3aff3811cd5a2ed9916a5686"><td class="memItemLeft" align="right" valign="top"><a id="a18cb4a5f3aff3811cd5a2ed9916a5686" name="a18cb4a5f3aff3811cd5a2ed9916a5686"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LessThanOrEqual</b> (std::string name, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a18cb4a5f3aff3811cd5a2ed9916a5686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a less than or equal predicate for a field name. <br /></td></tr>
<tr class="separator:a18cb4a5f3aff3811cd5a2ed9916a5686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a5f219264e2d6434be8cbf22438ad2" id="r_a34a5f219264e2d6434be8cbf22438ad2"><td class="memTemplParams" colspan="2"><a id="a34a5f219264e2d6434be8cbf22438ad2" name="a34a5f219264e2d6434be8cbf22438ad2"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a34a5f219264e2d6434be8cbf22438ad2"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LessThanOrEqual</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a34a5f219264e2d6434be8cbf22438ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a less than or equal predicate for an unbound term. <br /></td></tr>
<tr class="separator:a34a5f219264e2d6434be8cbf22438ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bef3bed364ed74910943f653899a39d" id="r_a0bef3bed364ed74910943f653899a39d"><td class="memItemLeft" align="right" valign="top"><a id="a0bef3bed364ed74910943f653899a39d" name="a0bef3bed364ed74910943f653899a39d"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GreaterThan</b> (std::string name, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a0bef3bed364ed74910943f653899a39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a greater than predicate for a field name. <br /></td></tr>
<tr class="separator:a0bef3bed364ed74910943f653899a39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176479b03eecbf8055a85fc79bb09751" id="r_a176479b03eecbf8055a85fc79bb09751"><td class="memTemplParams" colspan="2"><a id="a176479b03eecbf8055a85fc79bb09751" name="a176479b03eecbf8055a85fc79bb09751"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a176479b03eecbf8055a85fc79bb09751"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GreaterThan</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a176479b03eecbf8055a85fc79bb09751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a greater than predicate for an unbound term. <br /></td></tr>
<tr class="separator:a176479b03eecbf8055a85fc79bb09751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e018963e69bcfc3503242d4c2a380ae" id="r_a5e018963e69bcfc3503242d4c2a380ae"><td class="memItemLeft" align="right" valign="top"><a id="a5e018963e69bcfc3503242d4c2a380ae" name="a5e018963e69bcfc3503242d4c2a380ae"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GreaterThanOrEqual</b> (std::string name, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a5e018963e69bcfc3503242d4c2a380ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a greater than or equal predicate for a field name. <br /></td></tr>
<tr class="separator:a5e018963e69bcfc3503242d4c2a380ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75177f4b681450d78ce59b562ed96b3a" id="r_a75177f4b681450d78ce59b562ed96b3a"><td class="memTemplParams" colspan="2"><a id="a75177f4b681450d78ce59b562ed96b3a" name="a75177f4b681450d78ce59b562ed96b3a"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a75177f4b681450d78ce59b562ed96b3a"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GreaterThanOrEqual</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a75177f4b681450d78ce59b562ed96b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a greater than or equal predicate for an unbound term. <br /></td></tr>
<tr class="separator:a75177f4b681450d78ce59b562ed96b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099da8de1b919fdc4574458b308d9ea7" id="r_a099da8de1b919fdc4574458b308d9ea7"><td class="memItemLeft" align="right" valign="top"><a id="a099da8de1b919fdc4574458b308d9ea7" name="a099da8de1b919fdc4574458b308d9ea7"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Equal</b> (std::string name, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a099da8de1b919fdc4574458b308d9ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an equal predicate for a field name. <br /></td></tr>
<tr class="separator:a099da8de1b919fdc4574458b308d9ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07c339b5e2865d4772830744c769839" id="r_ae07c339b5e2865d4772830744c769839"><td class="memTemplParams" colspan="2"><a id="ae07c339b5e2865d4772830744c769839" name="ae07c339b5e2865d4772830744c769839"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:ae07c339b5e2865d4772830744c769839"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Equal</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:ae07c339b5e2865d4772830744c769839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an equal predicate for an unbound term. <br /></td></tr>
<tr class="separator:ae07c339b5e2865d4772830744c769839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c61c39ad47c427848c7ab2f0d2224f" id="r_a61c61c39ad47c427848c7ab2f0d2224f"><td class="memItemLeft" align="right" valign="top"><a id="a61c61c39ad47c427848c7ab2f0d2224f" name="a61c61c39ad47c427848c7ab2f0d2224f"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NotEqual</b> (std::string name, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a61c61c39ad47c427848c7ab2f0d2224f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a not equal predicate for a field name. <br /></td></tr>
<tr class="separator:a61c61c39ad47c427848c7ab2f0d2224f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a70b4514063c5189252f19b5c567b8b" id="r_a3a70b4514063c5189252f19b5c567b8b"><td class="memTemplParams" colspan="2"><a id="a3a70b4514063c5189252f19b5c567b8b" name="a3a70b4514063c5189252f19b5c567b8b"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a3a70b4514063c5189252f19b5c567b8b"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NotEqual</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:a3a70b4514063c5189252f19b5c567b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a not equal predicate for an unbound term. <br /></td></tr>
<tr class="separator:a3a70b4514063c5189252f19b5c567b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d953550427e80e5ec04179d194d141" id="r_af8d953550427e80e5ec04179d194d141"><td class="memItemLeft" align="right" valign="top"><a id="af8d953550427e80e5ec04179d194d141" name="af8d953550427e80e5ec04179d194d141"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StartsWith</b> (std::string name, std::string value)</td></tr>
<tr class="memdesc:af8d953550427e80e5ec04179d194d141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a starts with predicate for a field name. <br /></td></tr>
<tr class="separator:af8d953550427e80e5ec04179d194d141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce99b57596ff49331159cad97c52cdf" id="r_adce99b57596ff49331159cad97c52cdf"><td class="memTemplParams" colspan="2"><a id="adce99b57596ff49331159cad97c52cdf" name="adce99b57596ff49331159cad97c52cdf"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:adce99b57596ff49331159cad97c52cdf"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StartsWith</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, std::string value)</td></tr>
<tr class="memdesc:adce99b57596ff49331159cad97c52cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a starts with predicate for an unbound term. <br /></td></tr>
<tr class="separator:adce99b57596ff49331159cad97c52cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaed82242ca2977f607265a96fb3cf71" id="r_acaed82242ca2977f607265a96fb3cf71"><td class="memItemLeft" align="right" valign="top"><a id="acaed82242ca2977f607265a96fb3cf71" name="acaed82242ca2977f607265a96fb3cf71"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NotStartsWith</b> (std::string name, std::string value)</td></tr>
<tr class="memdesc:acaed82242ca2977f607265a96fb3cf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a not starts with predicate for a field name. <br /></td></tr>
<tr class="separator:acaed82242ca2977f607265a96fb3cf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac892e66726aa387b64fd92ec3a673a6b" id="r_ac892e66726aa387b64fd92ec3a673a6b"><td class="memTemplParams" colspan="2"><a id="ac892e66726aa387b64fd92ec3a673a6b" name="ac892e66726aa387b64fd92ec3a673a6b"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:ac892e66726aa387b64fd92ec3a673a6b"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NotStartsWith</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, std::string value)</td></tr>
<tr class="memdesc:ac892e66726aa387b64fd92ec3a673a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a not starts with predicate for an unbound term. <br /></td></tr>
<tr class="separator:ac892e66726aa387b64fd92ec3a673a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53e1579311db56887c64dc01b483ee4" id="r_aa53e1579311db56887c64dc01b483ee4"><td class="memItemLeft" align="right" valign="top"><a id="aa53e1579311db56887c64dc01b483ee4" name="aa53e1579311db56887c64dc01b483ee4"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>In</b> (std::string name, std::vector&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:aa53e1579311db56887c64dc01b483ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IN predicate for a field name. <br /></td></tr>
<tr class="separator:aa53e1579311db56887c64dc01b483ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6259024eade462b6d3b0f787a8762dfb" id="r_a6259024eade462b6d3b0f787a8762dfb"><td class="memTemplParams" colspan="2"><a id="a6259024eade462b6d3b0f787a8762dfb" name="a6259024eade462b6d3b0f787a8762dfb"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a6259024eade462b6d3b0f787a8762dfb"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>In</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, std::vector&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:a6259024eade462b6d3b0f787a8762dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IN predicate for an unbound term. <br /></td></tr>
<tr class="separator:a6259024eade462b6d3b0f787a8762dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec93911a24e06ec2528b602159381330" id="r_aec93911a24e06ec2528b602159381330"><td class="memItemLeft" align="right" valign="top"><a id="aec93911a24e06ec2528b602159381330" name="aec93911a24e06ec2528b602159381330"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>In</b> (std::string name, std::initializer_list&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:aec93911a24e06ec2528b602159381330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IN predicate for a field name with initializer list. <br /></td></tr>
<tr class="separator:aec93911a24e06ec2528b602159381330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47e47bc1053a2eb14f3399ed00da41e" id="r_aa47e47bc1053a2eb14f3399ed00da41e"><td class="memTemplParams" colspan="2"><a id="aa47e47bc1053a2eb14f3399ed00da41e" name="aa47e47bc1053a2eb14f3399ed00da41e"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:aa47e47bc1053a2eb14f3399ed00da41e"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>In</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, std::initializer_list&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:aa47e47bc1053a2eb14f3399ed00da41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IN predicate for an unbound term with initializer list. <br /></td></tr>
<tr class="separator:aa47e47bc1053a2eb14f3399ed00da41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54116334db7f9fd8cad08e06d0dcff3" id="r_ab54116334db7f9fd8cad08e06d0dcff3"><td class="memItemLeft" align="right" valign="top"><a id="ab54116334db7f9fd8cad08e06d0dcff3" name="ab54116334db7f9fd8cad08e06d0dcff3"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NotIn</b> (std::string name, std::vector&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:ab54116334db7f9fd8cad08e06d0dcff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT IN predicate for a field name. <br /></td></tr>
<tr class="separator:ab54116334db7f9fd8cad08e06d0dcff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376c819ded3b3f8c5fd59052b4c9253" id="r_a2376c819ded3b3f8c5fd59052b4c9253"><td class="memTemplParams" colspan="2"><a id="a2376c819ded3b3f8c5fd59052b4c9253" name="a2376c819ded3b3f8c5fd59052b4c9253"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a2376c819ded3b3f8c5fd59052b4c9253"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NotIn</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, std::vector&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:a2376c819ded3b3f8c5fd59052b4c9253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT IN predicate for an unbound term. <br /></td></tr>
<tr class="separator:a2376c819ded3b3f8c5fd59052b4c9253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e8c842f4badcd31f3597133eefec55" id="r_ac4e8c842f4badcd31f3597133eefec55"><td class="memItemLeft" align="right" valign="top"><a id="ac4e8c842f4badcd31f3597133eefec55" name="ac4e8c842f4badcd31f3597133eefec55"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NotIn</b> (std::string name, std::initializer_list&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:ac4e8c842f4badcd31f3597133eefec55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT IN predicate for a field name with initializer list. <br /></td></tr>
<tr class="separator:ac4e8c842f4badcd31f3597133eefec55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1fce5bc0b354547c2312b3694e860d" id="r_a1a1fce5bc0b354547c2312b3694e860d"><td class="memTemplParams" colspan="2"><a id="a1a1fce5bc0b354547c2312b3694e860d" name="a1a1fce5bc0b354547c2312b3694e860d"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a1a1fce5bc0b354547c2312b3694e860d"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NotIn</b> (std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, std::initializer_list&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:a1a1fce5bc0b354547c2312b3694e860d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a NOT IN predicate for an unbound term with initializer list. <br /></td></tr>
<tr class="separator:a1a1fce5bc0b354547c2312b3694e860d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47578da5d288503fdd285375d7cde3d" id="r_ad47578da5d288503fdd285375d7cde3d"><td class="memItemLeft" align="right" valign="top"><a id="ad47578da5d288503fdd285375d7cde3d" name="ad47578da5d288503fdd285375d7cde3d"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Predicate</b> (<a class="el" href="classiceberg_1_1Expression.html#a433076bdc34ce0b6d359313c6c7b8a9c">Expression::Operation</a> op, std::string name, <a class="el" href="classiceberg_1_1Literal.html">Literal</a> value)</td></tr>
<tr class="memdesc:ad47578da5d288503fdd285375d7cde3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a predicate with operation and single value. <br /></td></tr>
<tr class="separator:ad47578da5d288503fdd285375d7cde3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7ffc4fb5d0b3dbe19563c0ee78ed0c" id="r_a3b7ffc4fb5d0b3dbe19563c0ee78ed0c"><td class="memItemLeft" align="right" valign="top"><a id="a3b7ffc4fb5d0b3dbe19563c0ee78ed0c" name="a3b7ffc4fb5d0b3dbe19563c0ee78ed0c"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Predicate</b> (<a class="el" href="classiceberg_1_1Expression.html#a433076bdc34ce0b6d359313c6c7b8a9c">Expression::Operation</a> op, std::string name, std::vector&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:a3b7ffc4fb5d0b3dbe19563c0ee78ed0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a predicate with operation and multiple values. <br /></td></tr>
<tr class="separator:a3b7ffc4fb5d0b3dbe19563c0ee78ed0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8908c01193002b9cc1669955993f4b3" id="r_ad8908c01193002b9cc1669955993f4b3"><td class="memItemLeft" align="right" valign="top"><a id="ad8908c01193002b9cc1669955993f4b3" name="ad8908c01193002b9cc1669955993f4b3"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Predicate</b> (<a class="el" href="classiceberg_1_1Expression.html#a433076bdc34ce0b6d359313c6c7b8a9c">Expression::Operation</a> op, std::string name, std::initializer_list&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:ad8908c01193002b9cc1669955993f4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a predicate with operation and multiple values. <br /></td></tr>
<tr class="separator:ad8908c01193002b9cc1669955993f4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c13c818cb0b4c4c56a514f6de7be69c" id="r_a6c13c818cb0b4c4c56a514f6de7be69c"><td class="memItemLeft" align="right" valign="top"><a id="a6c13c818cb0b4c4c56a514f6de7be69c" name="a6c13c818cb0b4c4c56a514f6de7be69c"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; <a class="el" href="classiceberg_1_1BoundReference.html">BoundReference</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Predicate</b> (<a class="el" href="classiceberg_1_1Expression.html#a433076bdc34ce0b6d359313c6c7b8a9c">Expression::Operation</a> op, std::string name)</td></tr>
<tr class="memdesc:a6c13c818cb0b4c4c56a514f6de7be69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unary predicate (no values). <br /></td></tr>
<tr class="separator:a6c13c818cb0b4c4c56a514f6de7be69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a394a408af6f3b6232d34dc49ba44b" id="r_ac3a394a408af6f3b6232d34dc49ba44b"><td class="memTemplParams" colspan="2"><a id="ac3a394a408af6f3b6232d34dc49ba44b" name="ac3a394a408af6f3b6232d34dc49ba44b"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:ac3a394a408af6f3b6232d34dc49ba44b"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Predicate</b> (<a class="el" href="classiceberg_1_1Expression.html#a433076bdc34ce0b6d359313c6c7b8a9c">Expression::Operation</a> op, std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, std::vector&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:ac3a394a408af6f3b6232d34dc49ba44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a predicate for unbound term with multiple values. <br /></td></tr>
<tr class="separator:ac3a394a408af6f3b6232d34dc49ba44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68da90fa97e43d93ba45511a0590ca41" id="r_a68da90fa97e43d93ba45511a0590ca41"><td class="memTemplParams" colspan="2"><a id="a68da90fa97e43d93ba45511a0590ca41" name="a68da90fa97e43d93ba45511a0590ca41"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a68da90fa97e43d93ba45511a0590ca41"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Predicate</b> (<a class="el" href="classiceberg_1_1Expression.html#a433076bdc34ce0b6d359313c6c7b8a9c">Expression::Operation</a> op, std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr, std::initializer_list&lt; <a class="el" href="classiceberg_1_1Literal.html">Literal</a> &gt; values)</td></tr>
<tr class="memdesc:a68da90fa97e43d93ba45511a0590ca41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a predicate with operation and multiple values. <br /></td></tr>
<tr class="separator:a68da90fa97e43d93ba45511a0590ca41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8e5d44cd26c0d7ed9306f53f147e2e" id="r_a4f8e5d44cd26c0d7ed9306f53f147e2e"><td class="memTemplParams" colspan="2"><a id="a4f8e5d44cd26c0d7ed9306f53f147e2e" name="a4f8e5d44cd26c0d7ed9306f53f147e2e"></a>
template&lt;typename B &gt; </td></tr>
<tr class="memitem:a4f8e5d44cd26c0d7ed9306f53f147e2e"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundPredicateImpl.html">UnboundPredicateImpl</a>&lt; B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Predicate</b> (<a class="el" href="classiceberg_1_1Expression.html#a433076bdc34ce0b6d359313c6c7b8a9c">Expression::Operation</a> op, std::shared_ptr&lt; <a class="el" href="classiceberg_1_1UnboundTerm.html">UnboundTerm</a>&lt; B &gt; &gt; expr)</td></tr>
<tr class="memdesc:a4f8e5d44cd26c0d7ed9306f53f147e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unary predicate for unbound term. <br /></td></tr>
<tr class="separator:a4f8e5d44cd26c0d7ed9306f53f147e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9843c9fc8be17d06e7ee48fc56b92acc" id="r_a9843c9fc8be17d06e7ee48fc56b92acc"><td class="memItemLeft" align="right" valign="top"><a id="a9843c9fc8be17d06e7ee48fc56b92acc" name="a9843c9fc8be17d06e7ee48fc56b92acc"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1True.html">True</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AlwaysTrue</b> ()</td></tr>
<tr class="memdesc:a9843c9fc8be17d06e7ee48fc56b92acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the always true expression. <br /></td></tr>
<tr class="separator:a9843c9fc8be17d06e7ee48fc56b92acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7ec85c686c0a38ac13964d8528a097" id="r_a4f7ec85c686c0a38ac13964d8528a097"><td class="memItemLeft" align="right" valign="top"><a id="a4f7ec85c686c0a38ac13964d8528a097" name="a4f7ec85c686c0a38ac13964d8528a097"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1False.html">False</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AlwaysFalse</b> ()</td></tr>
<tr class="memdesc:a4f7ec85c686c0a38ac13964d8528a097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the always false expression. <br /></td></tr>
<tr class="separator:a4f7ec85c686c0a38ac13964d8528a097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482a0f9ec93ef525cd9cf47b78b36a40" id="r_a482a0f9ec93ef525cd9cf47b78b36a40"><td class="memItemLeft" align="right" valign="top"><a id="a482a0f9ec93ef525cd9cf47b78b36a40" name="a482a0f9ec93ef525cd9cf47b78b36a40"></a>
static std::shared_ptr&lt; <a class="el" href="classiceberg_1_1NamedReference.html">NamedReference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ref</b> (std::string name)</td></tr>
<tr class="memdesc:a482a0f9ec93ef525cd9cf47b78b36a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a named reference to a field. <br /></td></tr>
<tr class="separator:a482a0f9ec93ef525cd9cf47b78b36a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8c62790ca12c95088eccc1601f8ef" id="r_ae9b8c62790ca12c95088eccc1601f8ef"><td class="memItemLeft" align="right" valign="top"><a id="ae9b8c62790ca12c95088eccc1601f8ef" name="ae9b8c62790ca12c95088eccc1601f8ef"></a>
static <a class="el" href="classiceberg_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Lit</b> (Literal::Value value, std::shared_ptr&lt; <a class="el" href="classiceberg_1_1PrimitiveType.html">PrimitiveType</a> &gt; type)</td></tr>
<tr class="memdesc:ae9b8c62790ca12c95088eccc1601f8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a literal from a value. <br /></td></tr>
<tr class="separator:ae9b8c62790ca12c95088eccc1601f8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Fluent APIs to create expressions. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`ExpressionError`</td><td>for invalid expression. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a19757ac2b0dcf6e0b3acbb861b934e5e" name="a19757ac2b0dcf6e0b3acbb861b934e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19757ac2b0dcf6e0b3acbb861b934e5e">&#9670;&#160;</a></span>Not()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt; iceberg::Expressions::Not </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classiceberg_1_1Expression.html">Expression</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a NOT expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The expression to negate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negated expression with optimizations applied:<ul>
<li>not(true) returns false</li>
<li>not(false) returns true</li>
<li>not(not(x)) returns x </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>iceberg/expression/<a class="el" href="expressions_8h_source.html">expressions.h</a></li>
<li>iceberg/expression/<b>expressions.cc</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
