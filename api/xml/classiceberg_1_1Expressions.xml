<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="classiceberg_1_1Expressions" kind="class" language="C++" prot="public">
    <compoundname>iceberg::Expressions</compoundname>
    <includes refid="expressions_8h" local="no">expressions.h</includes>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ad5129434b9a0e45e3fd3ffd53f5a3a40" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Expression" kindref="compound">Expression</ref> &gt;</type>
        <definition>static std::shared_ptr&lt; Expression &gt; iceberg::Expressions::And</definition>
        <argsstring>(std::shared_ptr&lt; Expression &gt; left, std::shared_ptr&lt; Expression &gt; right, Args &amp;&amp;... args)</argsstring>
        <name>And</name>
        <qualifiedname>iceberg::Expressions::And</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Expression" kindref="compound">Expression</ref> &gt;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Expression" kindref="compound">Expression</ref> &gt;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
    <requiresclause>std::conjunction_v&lt;std::is_same&lt;Args, std::shared_ptr&lt;Expression&gt;&gt;...&gt;    </requiresclause>
        <briefdescription>
<para>Create an AND expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="48" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="48" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ab6f02015ae774f2ee14bcb7dfba2c287" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Expression" kindref="compound">Expression</ref> &gt;</type>
        <definition>static std::shared_ptr&lt; Expression &gt; iceberg::Expressions::Or</definition>
        <argsstring>(std::shared_ptr&lt; Expression &gt; left, std::shared_ptr&lt; Expression &gt; right, Args &amp;&amp;... args)</argsstring>
        <name>Or</name>
        <qualifiedname>iceberg::Expressions::Or</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Expression" kindref="compound">Expression</ref> &gt;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Expression" kindref="compound">Expression</ref> &gt;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
    <requiresclause>std::conjunction_v&lt;std::is_same&lt;Args, std::shared_ptr&lt;Expression&gt;&gt;...&gt;    </requiresclause>
        <briefdescription>
<para>Create an OR expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="61" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="61" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a19757ac2b0dcf6e0b3acbb861b934e5e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Expression" kindref="compound">Expression</ref> &gt;</type>
        <definition>std::shared_ptr&lt; Expression &gt; iceberg::Expressions::Not</definition>
        <argsstring>(std::shared_ptr&lt; Expression &gt; child)</argsstring>
        <name>Not</name>
        <qualifiedname>iceberg::Expressions::Not</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Expression" kindref="compound">Expression</ref> &gt;</type>
          <declname>child</declname>
        </param>
        <briefdescription>
<para>Create a NOT expression. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>child</parametername>
</parameternamelist>
<parameterdescription>
<para>The expression to negate </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A negated expression with optimizations applied:<itemizedlist>
<listitem><para>not(true) returns false</para>
</listitem><listitem><para>not(false) returns true</para>
</listitem><listitem><para>not(not(x)) returns x </para>
</listitem></itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="78" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="31" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a3794ab614f6d31e8ca375fc2cb461868" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTransform" kindref="compound">UnboundTransform</ref> &gt;</type>
        <definition>std::shared_ptr&lt; UnboundTransform &gt; iceberg::Expressions::Bucket</definition>
        <argsstring>(std::string name, int32_t num_buckets)</argsstring>
        <name>Bucket</name>
        <qualifiedname>iceberg::Expressions::Bucket</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>num_buckets</declname>
        </param>
        <briefdescription>
<para>Create a bucket transform term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="83" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="38" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a6066a65c379f703138e1b0abd8ed146d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTransform" kindref="compound">UnboundTransform</ref> &gt;</type>
        <definition>std::shared_ptr&lt; UnboundTransform &gt; iceberg::Expressions::Year</definition>
        <argsstring>(std::string name)</argsstring>
        <name>Year</name>
        <qualifiedname>iceberg::Expressions::Year</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a year transform term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="86" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="46" bodyend="50"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1aca5010427d1084bab3a514e4bfcdbfe1" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTransform" kindref="compound">UnboundTransform</ref> &gt;</type>
        <definition>std::shared_ptr&lt; UnboundTransform &gt; iceberg::Expressions::Month</definition>
        <argsstring>(std::string name)</argsstring>
        <name>Month</name>
        <qualifiedname>iceberg::Expressions::Month</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a month transform term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="89" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="52" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ada6b378fd8e69075a55ef3ec11e5e0f7" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTransform" kindref="compound">UnboundTransform</ref> &gt;</type>
        <definition>std::shared_ptr&lt; UnboundTransform &gt; iceberg::Expressions::Day</definition>
        <argsstring>(std::string name)</argsstring>
        <name>Day</name>
        <qualifiedname>iceberg::Expressions::Day</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a day transform term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="92" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="58" bodyend="62"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a68a082b7916d62b3af9822e3f8db98b6" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTransform" kindref="compound">UnboundTransform</ref> &gt;</type>
        <definition>std::shared_ptr&lt; UnboundTransform &gt; iceberg::Expressions::Hour</definition>
        <argsstring>(std::string name)</argsstring>
        <name>Hour</name>
        <qualifiedname>iceberg::Expressions::Hour</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create an hour transform term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="95" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="64" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1aadbb6b60bcaad6043a65b90a78bff09b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTransform" kindref="compound">UnboundTransform</ref> &gt;</type>
        <definition>std::shared_ptr&lt; UnboundTransform &gt; iceberg::Expressions::Truncate</definition>
        <argsstring>(std::string name, int32_t width)</argsstring>
        <name>Truncate</name>
        <qualifiedname>iceberg::Expressions::Truncate</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>width</declname>
        </param>
        <briefdescription>
<para>Create a truncate transform term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="98" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="70" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a0c80fa9b7e8d7513e63696e8c0076a25" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTransform" kindref="compound">UnboundTransform</ref> &gt;</type>
        <definition>std::shared_ptr&lt; UnboundTransform &gt; iceberg::Expressions::Transform</definition>
        <argsstring>(std::string name, std::shared_ptr&lt; Transform &gt; transform)</argsstring>
        <name>Transform</name>
        <qualifiedname>iceberg::Expressions::Transform</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1Transform" kindref="compound">Transform</ref> &gt;</type>
          <declname>transform</declname>
        </param>
        <briefdescription>
<para>Create a transform expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="101" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="77" bodyend="83"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ac48344e4a88a25023fd31546119b31ac" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Count</definition>
        <argsstring>(std::string name)</argsstring>
        <name>Count</name>
        <qualifiedname>iceberg::Expressions::Count</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a COUNT aggregate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="107" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="87" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a328c82cdda89b0daa9c6bf05a1da0980" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Count</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; BoundReference &gt; &gt; expr)</argsstring>
        <name>Count</name>
        <qualifiedname>iceberg::Expressions::Count</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a COUNT aggregate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="110" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="92" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ad31a1d7ee958d88faa2a7e67ff3b74ff" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::CountNull</definition>
        <argsstring>(std::string name)</argsstring>
        <name>CountNull</name>
        <qualifiedname>iceberg::Expressions::CountNull</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a COUNT_NULL aggregate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="114" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="99" bodyend="102"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a07a147363fa3c91f399dae0f074500f9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::CountNull</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; BoundReference &gt; &gt; expr)</argsstring>
        <name>CountNull</name>
        <qualifiedname>iceberg::Expressions::CountNull</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a COUNT_NULL aggregate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="118" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="104" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a40fe79bac9d13e14f97b77634b555a5f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::CountNotNull</definition>
        <argsstring>(std::string name)</argsstring>
        <name>CountNotNull</name>
        <qualifiedname>iceberg::Expressions::CountNotNull</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a COUNT_NOT_NULL aggregate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="122" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="112" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a6d9ffa5f975ea353fef8ffa55a1cad8b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::CountNotNull</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; BoundReference &gt; &gt; expr)</argsstring>
        <name>CountNotNull</name>
        <qualifiedname>iceberg::Expressions::CountNotNull</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a COUNT_NOT_NULL aggregate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="126" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="117" bodyend="122"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ad2b19a7cca0670cd4933042a1fecba6b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::CountStar</definition>
        <argsstring>()</argsstring>
        <name>CountStar</name>
        <qualifiedname>iceberg::Expressions::CountStar</qualifiedname>
        <briefdescription>
<para>Create a COUNT(*) aggregate. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="130" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="124" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a76181bfd24b9c17e2b52f82d68c7908d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Max</definition>
        <argsstring>(std::string name)</argsstring>
        <name>Max</name>
        <qualifiedname>iceberg::Expressions::Max</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a MAX aggregate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="133" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="130" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ac470b99828d4c9cd79f60033409af1f0" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Max</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; BoundReference &gt; &gt; expr)</argsstring>
        <name>Max</name>
        <qualifiedname>iceberg::Expressions::Max</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a MAX aggregate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="136" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="134" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ad76805d74bc40350a0d92e5d6d95c556" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundTransform" kindref="compound">BoundTransform</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundTransform &gt; &gt; iceberg::Expressions::Max</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; BoundTransform &gt; &gt; expr)</argsstring>
        <name>Max</name>
        <qualifiedname>iceberg::Expressions::Max</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; <ref refid="classiceberg_1_1BoundTransform" kindref="compound">BoundTransform</ref> &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a MAX aggregate for an unbound transform term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="139" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="141" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a260d57ba12656b8a65ee22a7d949b552" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Min</definition>
        <argsstring>(std::string name)</argsstring>
        <name>Min</name>
        <qualifiedname>iceberg::Expressions::Min</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a MIN aggregate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="143" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="148" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a793dda1fb61f27cb5ccb5fecf7f644f9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Min</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; BoundReference &gt; &gt; expr)</argsstring>
        <name>Min</name>
        <qualifiedname>iceberg::Expressions::Min</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a MIN aggregate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="146" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="152" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1afa13eedbe6c5dfb50c5b6dfef3645ca2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundAggregateImpl" kindref="compound">UnboundAggregateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundTransform" kindref="compound">BoundTransform</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundAggregateImpl&lt; BoundTransform &gt; &gt; iceberg::Expressions::Min</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; BoundTransform &gt; &gt; expr)</argsstring>
        <name>Min</name>
        <qualifiedname>iceberg::Expressions::Min</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; <ref refid="classiceberg_1_1BoundTransform" kindref="compound">BoundTransform</ref> &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a MIN aggregate for an unbound transform term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="149" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="159" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ac60a4b5dba2748af3fcb53d4434e290d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::IsNull</definition>
        <argsstring>(std::string name)</argsstring>
        <name>IsNull</name>
        <qualifiedname>iceberg::Expressions::IsNull</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create an IS NULL predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="155" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="168" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ad90891efda7a0f4b1ff876effe0c9364" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::IsNull</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr)</argsstring>
        <name>IsNull</name>
        <qualifiedname>iceberg::Expressions::IsNull</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create an IS NULL predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="159" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="159" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a495669f931ea0ba80d4ed0581c53598d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::NotNull</definition>
        <argsstring>(std::string name)</argsstring>
        <name>NotNull</name>
        <qualifiedname>iceberg::Expressions::NotNull</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a NOT NULL predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="168" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="173" bodyend="176"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a1a845a812dfed8e04455744195a49ba2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::NotNull</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr)</argsstring>
        <name>NotNull</name>
        <qualifiedname>iceberg::Expressions::NotNull</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a NOT NULL predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="172" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="172" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1aed115b3c4c0546727ee63a4d925cbda0" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::IsNaN</definition>
        <argsstring>(std::string name)</argsstring>
        <name>IsNaN</name>
        <qualifiedname>iceberg::Expressions::IsNaN</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create an IS NaN predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="181" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="178" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a7eed7e94728431a5d6ed1951eecc2928" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::IsNaN</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr)</argsstring>
        <name>IsNaN</name>
        <qualifiedname>iceberg::Expressions::IsNaN</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create an IS NaN predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="185" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="185" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a323f4e5e0808914a3e2a7bf387109ca1" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::NotNaN</definition>
        <argsstring>(std::string name)</argsstring>
        <name>NotNaN</name>
        <qualifiedname>iceberg::Expressions::NotNaN</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a NOT NaN predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="194" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="183" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a61b3c1919f005602a04a323d03430154" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::NotNaN</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr)</argsstring>
        <name>NotNaN</name>
        <qualifiedname>iceberg::Expressions::NotNaN</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a NOT NaN predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="198" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="198" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a83afed36da05da0cb524800844b0974f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::LessThan</definition>
        <argsstring>(std::string name, Literal value)</argsstring>
        <name>LessThan</name>
        <qualifiedname>iceberg::Expressions::LessThan</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a less than predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="209" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="190" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ad00e0e79f35bbe29f6fb9e2ba8702225" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::LessThan</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, Literal value)</argsstring>
        <name>LessThan</name>
        <qualifiedname>iceberg::Expressions::LessThan</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a less than predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="214" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="214" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a18cb4a5f3aff3811cd5a2ed9916a5686" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::LessThanOrEqual</definition>
        <argsstring>(std::string name, Literal value)</argsstring>
        <name>LessThanOrEqual</name>
        <qualifiedname>iceberg::Expressions::LessThanOrEqual</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a less than or equal predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="223" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="195" bodyend="198"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a34a5f219264e2d6434be8cbf22438ad2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::LessThanOrEqual</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, Literal value)</argsstring>
        <name>LessThanOrEqual</name>
        <qualifiedname>iceberg::Expressions::LessThanOrEqual</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a less than or equal predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="228" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="228" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a0bef3bed364ed74910943f653899a39d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::GreaterThan</definition>
        <argsstring>(std::string name, Literal value)</argsstring>
        <name>GreaterThan</name>
        <qualifiedname>iceberg::Expressions::GreaterThan</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a greater than predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="237" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="200" bodyend="203"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a176479b03eecbf8055a85fc79bb09751" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::GreaterThan</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, Literal value)</argsstring>
        <name>GreaterThan</name>
        <qualifiedname>iceberg::Expressions::GreaterThan</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a greater than predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="242" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="242" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a5e018963e69bcfc3503242d4c2a380ae" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::GreaterThanOrEqual</definition>
        <argsstring>(std::string name, Literal value)</argsstring>
        <name>GreaterThanOrEqual</name>
        <qualifiedname>iceberg::Expressions::GreaterThanOrEqual</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a greater than or equal predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="251" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="205" bodyend="208"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a75177f4b681450d78ce59b562ed96b3a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::GreaterThanOrEqual</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, Literal value)</argsstring>
        <name>GreaterThanOrEqual</name>
        <qualifiedname>iceberg::Expressions::GreaterThanOrEqual</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a greater than or equal predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="256" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="256" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a099da8de1b919fdc4574458b308d9ea7" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Equal</definition>
        <argsstring>(std::string name, Literal value)</argsstring>
        <name>Equal</name>
        <qualifiedname>iceberg::Expressions::Equal</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create an equal predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="265" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="210" bodyend="213"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ae07c339b5e2865d4772830744c769839" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::Equal</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, Literal value)</argsstring>
        <name>Equal</name>
        <qualifiedname>iceberg::Expressions::Equal</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create an equal predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="270" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="270" bodyend="276"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a61c61c39ad47c427848c7ab2f0d2224f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::NotEqual</definition>
        <argsstring>(std::string name, Literal value)</argsstring>
        <name>NotEqual</name>
        <qualifiedname>iceberg::Expressions::NotEqual</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a not equal predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="279" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="215" bodyend="218"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a3a70b4514063c5189252f19b5c567b8b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::NotEqual</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, Literal value)</argsstring>
        <name>NotEqual</name>
        <qualifiedname>iceberg::Expressions::NotEqual</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a not equal predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="284" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="284" bodyend="290"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1af8d953550427e80e5ec04179d194d141" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::StartsWith</definition>
        <argsstring>(std::string name, std::string value)</argsstring>
        <name>StartsWith</name>
        <qualifiedname>iceberg::Expressions::StartsWith</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a starts with predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="295" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="222" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1adce99b57596ff49331159cad97c52cdf" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::StartsWith</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, std::string value)</argsstring>
        <name>StartsWith</name>
        <qualifiedname>iceberg::Expressions::StartsWith</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a starts with predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="300" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="300" bodyend="307"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1acaed82242ca2977f607265a96fb3cf71" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::NotStartsWith</definition>
        <argsstring>(std::string name, std::string value)</argsstring>
        <name>NotStartsWith</name>
        <qualifiedname>iceberg::Expressions::NotStartsWith</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a not starts with predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="310" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="227" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ac892e66726aa387b64fd92ec3a673a6b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::NotStartsWith</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, std::string value)</argsstring>
        <name>NotStartsWith</name>
        <qualifiedname>iceberg::Expressions::NotStartsWith</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a not starts with predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="315" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="315" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1aa53e1579311db56887c64dc01b483ee4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::In</definition>
        <argsstring>(std::string name, std::vector&lt; Literal &gt; values)</argsstring>
        <name>In</name>
        <qualifiedname>iceberg::Expressions::In</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create an IN predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="327" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="234" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a6259024eade462b6d3b0f787a8762dfb" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::In</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, std::vector&lt; Literal &gt; values)</argsstring>
        <name>In</name>
        <qualifiedname>iceberg::Expressions::In</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create an IN predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="332" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="332" bodyend="338"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1aec93911a24e06ec2528b602159381330" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::In</definition>
        <argsstring>(std::string name, std::initializer_list&lt; Literal &gt; values)</argsstring>
        <name>In</name>
        <qualifiedname>iceberg::Expressions::In</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create an IN predicate for a field name with initializer list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="341" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="239" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1aa47e47bc1053a2eb14f3399ed00da41e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::In</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, std::initializer_list&lt; Literal &gt; values)</argsstring>
        <name>In</name>
        <qualifiedname>iceberg::Expressions::In</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create an IN predicate for an unbound term with initializer list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="346" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="346" bodyend="349"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ab54116334db7f9fd8cad08e06d0dcff3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::NotIn</definition>
        <argsstring>(std::string name, std::vector&lt; Literal &gt; values)</argsstring>
        <name>NotIn</name>
        <qualifiedname>iceberg::Expressions::NotIn</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a NOT IN predicate for a field name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="352" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="244" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a2376c819ded3b3f8c5fd59052b4c9253" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::NotIn</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, std::vector&lt; Literal &gt; values)</argsstring>
        <name>NotIn</name>
        <qualifiedname>iceberg::Expressions::NotIn</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a NOT IN predicate for an unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="357" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="357" bodyend="363"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ac4e8c842f4badcd31f3597133eefec55" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::NotIn</definition>
        <argsstring>(std::string name, std::initializer_list&lt; Literal &gt; values)</argsstring>
        <name>NotIn</name>
        <qualifiedname>iceberg::Expressions::NotIn</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a NOT IN predicate for a field name with initializer list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="366" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="249" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a1a1fce5bc0b354547c2312b3694e860d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::NotIn</definition>
        <argsstring>(std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, std::initializer_list&lt; Literal &gt; values)</argsstring>
        <name>NotIn</name>
        <qualifiedname>iceberg::Expressions::NotIn</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a NOT IN predicate for an unbound term with initializer list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="371" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="371" bodyend="374"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ad47578da5d288503fdd285375d7cde3d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Predicate</definition>
        <argsstring>(Expression::Operation op, std::string name, Literal value)</argsstring>
        <name>Predicate</name>
        <qualifiedname>iceberg::Expressions::Predicate</qualifiedname>
        <param>
          <type><ref refid="classiceberg_1_1Expression_1a433076bdc34ce0b6d359313c6c7b8a9c" kindref="member">Expression::Operation</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Create a predicate with operation and single value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="379" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="256" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a3b7ffc4fb5d0b3dbe19563c0ee78ed0c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Predicate</definition>
        <argsstring>(Expression::Operation op, std::string name, std::vector&lt; Literal &gt; values)</argsstring>
        <name>Predicate</name>
        <qualifiedname>iceberg::Expressions::Predicate</qualifiedname>
        <param>
          <type><ref refid="classiceberg_1_1Expression_1a433076bdc34ce0b6d359313c6c7b8a9c" kindref="member">Expression::Operation</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a predicate with operation and multiple values. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="383" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="263" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ad8908c01193002b9cc1669955993f4b3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Predicate</definition>
        <argsstring>(Expression::Operation op, std::string name, std::initializer_list&lt; Literal &gt; values)</argsstring>
        <name>Predicate</name>
        <qualifiedname>iceberg::Expressions::Predicate</qualifiedname>
        <param>
          <type><ref refid="classiceberg_1_1Expression_1a433076bdc34ce0b6d359313c6c7b8a9c" kindref="member">Expression::Operation</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a predicate with operation and multiple values. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="387" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="270" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a6c13c818cb0b4c4c56a514f6de7be69c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; <ref refid="classiceberg_1_1BoundReference" kindref="compound">BoundReference</ref> &gt; &gt;</type>
        <definition>std::shared_ptr&lt; UnboundPredicateImpl&lt; BoundReference &gt; &gt; iceberg::Expressions::Predicate</definition>
        <argsstring>(Expression::Operation op, std::string name)</argsstring>
        <name>Predicate</name>
        <qualifiedname>iceberg::Expressions::Predicate</qualifiedname>
        <param>
          <type><ref refid="classiceberg_1_1Expression_1a433076bdc34ce0b6d359313c6c7b8a9c" kindref="member">Expression::Operation</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a unary predicate (no values). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="391" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="275" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ac3a394a408af6f3b6232d34dc49ba44b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::Predicate</definition>
        <argsstring>(Expression::Operation op, std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, std::vector&lt; Literal &gt; values)</argsstring>
        <name>Predicate</name>
        <qualifiedname>iceberg::Expressions::Predicate</qualifiedname>
        <param>
          <type><ref refid="classiceberg_1_1Expression_1a433076bdc34ce0b6d359313c6c7b8a9c" kindref="member">Expression::Operation</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a predicate for unbound term with multiple values. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="396" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="396" bodyend="402"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a68da90fa97e43d93ba45511a0590ca41" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::Predicate</definition>
        <argsstring>(Expression::Operation op, std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr, std::initializer_list&lt; Literal &gt; values)</argsstring>
        <name>Predicate</name>
        <qualifiedname>iceberg::Expressions::Predicate</qualifiedname>
        <param>
          <type><ref refid="classiceberg_1_1Expression_1a433076bdc34ce0b6d359313c6c7b8a9c" kindref="member">Expression::Operation</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::initializer_list&lt; <ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref> &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a predicate with operation and multiple values. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="406" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="406" bodyend="410"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a4f8e5d44cd26c0d7ed9306f53f147e2e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundPredicateImpl" kindref="compound">UnboundPredicateImpl</ref>&lt; B &gt; &gt;</type>
        <definition>static std::shared_ptr&lt; UnboundPredicateImpl&lt; B &gt; &gt; iceberg::Expressions::Predicate</definition>
        <argsstring>(Expression::Operation op, std::shared_ptr&lt; UnboundTerm&lt; B &gt; &gt; expr)</argsstring>
        <name>Predicate</name>
        <qualifiedname>iceberg::Expressions::Predicate</qualifiedname>
        <param>
          <type><ref refid="classiceberg_1_1Expression_1a433076bdc34ce0b6d359313c6c7b8a9c" kindref="member">Expression::Operation</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1UnboundTerm" kindref="compound">UnboundTerm</ref>&lt; B &gt; &gt;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Create a unary predicate for unbound term. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="414" column="26" bodyfile="iceberg/expression/expressions.h" bodystart="414" bodyend="419"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a9843c9fc8be17d06e7ee48fc56b92acc" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1True" kindref="compound">True</ref> &gt;</type>
        <definition>std::shared_ptr&lt; True &gt; iceberg::Expressions::AlwaysTrue</definition>
        <argsstring>()</argsstring>
        <name>AlwaysTrue</name>
        <qualifiedname>iceberg::Expressions::AlwaysTrue</qualifiedname>
        <briefdescription>
<para>Return the always true expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="424" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="284" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a4f7ec85c686c0a38ac13964d8528a097" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1False" kindref="compound">False</ref> &gt;</type>
        <definition>std::shared_ptr&lt; False &gt; iceberg::Expressions::AlwaysFalse</definition>
        <argsstring>()</argsstring>
        <name>AlwaysFalse</name>
        <qualifiedname>iceberg::Expressions::AlwaysFalse</qualifiedname>
        <briefdescription>
<para>Return the always false expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="427" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="286" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1a482a0f9ec93ef525cd9cf47b78b36a40" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1NamedReference" kindref="compound">NamedReference</ref> &gt;</type>
        <definition>std::shared_ptr&lt; NamedReference &gt; iceberg::Expressions::Ref</definition>
        <argsstring>(std::string name)</argsstring>
        <name>Ref</name>
        <qualifiedname>iceberg::Expressions::Ref</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Create a named reference to a field. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="432" column="26" bodyfile="iceberg/expression/expressions.cc" bodystart="290" bodyend="293"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Expressions_1ae9b8c62790ca12c95088eccc1601f8ef" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiceberg_1_1Literal" kindref="compound">Literal</ref></type>
        <definition>Literal iceberg::Expressions::Lit</definition>
        <argsstring>(Literal::Value value, std::shared_ptr&lt; PrimitiveType &gt; type)</argsstring>
        <name>Lit</name>
        <qualifiedname>iceberg::Expressions::Lit</qualifiedname>
        <param>
          <type>Literal::Value</type>
          <declname>value</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classiceberg_1_1PrimitiveType" kindref="compound">PrimitiveType</ref> &gt;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>Create a literal from a value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/expression/expressions.h" line="435" column="18" bodyfile="iceberg/expression/expressions.cc" bodystart="295" bodyend="297"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Fluent APIs to create expressions. </para>
    </briefdescription>
    <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>`ExpressionError`</parametername>
</parameternamelist>
<parameterdescription>
<para>for invalid expression. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
    </detaileddescription>
    <location file="iceberg/expression/expressions.h" line="42" column="1" bodyfile="iceberg/expression/expressions.h" bodystart="42" bodyend="436"/>
    <listofallmembers>
      <member refid="classiceberg_1_1Expressions_1a4f7ec85c686c0a38ac13964d8528a097" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>AlwaysFalse</name></member>
      <member refid="classiceberg_1_1Expressions_1a9843c9fc8be17d06e7ee48fc56b92acc" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>AlwaysTrue</name></member>
      <member refid="classiceberg_1_1Expressions_1ad5129434b9a0e45e3fd3ffd53f5a3a40" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>And</name></member>
      <member refid="classiceberg_1_1Expressions_1a3794ab614f6d31e8ca375fc2cb461868" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Bucket</name></member>
      <member refid="classiceberg_1_1Expressions_1ac48344e4a88a25023fd31546119b31ac" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Count</name></member>
      <member refid="classiceberg_1_1Expressions_1a328c82cdda89b0daa9c6bf05a1da0980" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Count</name></member>
      <member refid="classiceberg_1_1Expressions_1a40fe79bac9d13e14f97b77634b555a5f" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>CountNotNull</name></member>
      <member refid="classiceberg_1_1Expressions_1a6d9ffa5f975ea353fef8ffa55a1cad8b" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>CountNotNull</name></member>
      <member refid="classiceberg_1_1Expressions_1ad31a1d7ee958d88faa2a7e67ff3b74ff" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>CountNull</name></member>
      <member refid="classiceberg_1_1Expressions_1a07a147363fa3c91f399dae0f074500f9" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>CountNull</name></member>
      <member refid="classiceberg_1_1Expressions_1ad2b19a7cca0670cd4933042a1fecba6b" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>CountStar</name></member>
      <member refid="classiceberg_1_1Expressions_1ada6b378fd8e69075a55ef3ec11e5e0f7" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Day</name></member>
      <member refid="classiceberg_1_1Expressions_1a099da8de1b919fdc4574458b308d9ea7" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Equal</name></member>
      <member refid="classiceberg_1_1Expressions_1ae07c339b5e2865d4772830744c769839" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Equal</name></member>
      <member refid="classiceberg_1_1Expressions_1a0bef3bed364ed74910943f653899a39d" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>GreaterThan</name></member>
      <member refid="classiceberg_1_1Expressions_1a176479b03eecbf8055a85fc79bb09751" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>GreaterThan</name></member>
      <member refid="classiceberg_1_1Expressions_1a5e018963e69bcfc3503242d4c2a380ae" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>GreaterThanOrEqual</name></member>
      <member refid="classiceberg_1_1Expressions_1a75177f4b681450d78ce59b562ed96b3a" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>GreaterThanOrEqual</name></member>
      <member refid="classiceberg_1_1Expressions_1a68a082b7916d62b3af9822e3f8db98b6" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Hour</name></member>
      <member refid="classiceberg_1_1Expressions_1aa53e1579311db56887c64dc01b483ee4" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>In</name></member>
      <member refid="classiceberg_1_1Expressions_1a6259024eade462b6d3b0f787a8762dfb" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>In</name></member>
      <member refid="classiceberg_1_1Expressions_1aec93911a24e06ec2528b602159381330" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>In</name></member>
      <member refid="classiceberg_1_1Expressions_1aa47e47bc1053a2eb14f3399ed00da41e" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>In</name></member>
      <member refid="classiceberg_1_1Expressions_1aed115b3c4c0546727ee63a4d925cbda0" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>IsNaN</name></member>
      <member refid="classiceberg_1_1Expressions_1a7eed7e94728431a5d6ed1951eecc2928" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>IsNaN</name></member>
      <member refid="classiceberg_1_1Expressions_1ac60a4b5dba2748af3fcb53d4434e290d" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>IsNull</name></member>
      <member refid="classiceberg_1_1Expressions_1ad90891efda7a0f4b1ff876effe0c9364" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>IsNull</name></member>
      <member refid="classiceberg_1_1Expressions_1a83afed36da05da0cb524800844b0974f" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>LessThan</name></member>
      <member refid="classiceberg_1_1Expressions_1ad00e0e79f35bbe29f6fb9e2ba8702225" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>LessThan</name></member>
      <member refid="classiceberg_1_1Expressions_1a18cb4a5f3aff3811cd5a2ed9916a5686" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>LessThanOrEqual</name></member>
      <member refid="classiceberg_1_1Expressions_1a34a5f219264e2d6434be8cbf22438ad2" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>LessThanOrEqual</name></member>
      <member refid="classiceberg_1_1Expressions_1ae9b8c62790ca12c95088eccc1601f8ef" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Lit</name></member>
      <member refid="classiceberg_1_1Expressions_1a76181bfd24b9c17e2b52f82d68c7908d" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Max</name></member>
      <member refid="classiceberg_1_1Expressions_1ac470b99828d4c9cd79f60033409af1f0" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Max</name></member>
      <member refid="classiceberg_1_1Expressions_1ad76805d74bc40350a0d92e5d6d95c556" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Max</name></member>
      <member refid="classiceberg_1_1Expressions_1a260d57ba12656b8a65ee22a7d949b552" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Min</name></member>
      <member refid="classiceberg_1_1Expressions_1a793dda1fb61f27cb5ccb5fecf7f644f9" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Min</name></member>
      <member refid="classiceberg_1_1Expressions_1afa13eedbe6c5dfb50c5b6dfef3645ca2" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Min</name></member>
      <member refid="classiceberg_1_1Expressions_1aca5010427d1084bab3a514e4bfcdbfe1" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Month</name></member>
      <member refid="classiceberg_1_1Expressions_1a19757ac2b0dcf6e0b3acbb861b934e5e" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Not</name></member>
      <member refid="classiceberg_1_1Expressions_1a61c61c39ad47c427848c7ab2f0d2224f" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotEqual</name></member>
      <member refid="classiceberg_1_1Expressions_1a3a70b4514063c5189252f19b5c567b8b" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotEqual</name></member>
      <member refid="classiceberg_1_1Expressions_1ab54116334db7f9fd8cad08e06d0dcff3" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotIn</name></member>
      <member refid="classiceberg_1_1Expressions_1a2376c819ded3b3f8c5fd59052b4c9253" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotIn</name></member>
      <member refid="classiceberg_1_1Expressions_1ac4e8c842f4badcd31f3597133eefec55" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotIn</name></member>
      <member refid="classiceberg_1_1Expressions_1a1a1fce5bc0b354547c2312b3694e860d" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotIn</name></member>
      <member refid="classiceberg_1_1Expressions_1a323f4e5e0808914a3e2a7bf387109ca1" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotNaN</name></member>
      <member refid="classiceberg_1_1Expressions_1a61b3c1919f005602a04a323d03430154" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotNaN</name></member>
      <member refid="classiceberg_1_1Expressions_1a495669f931ea0ba80d4ed0581c53598d" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotNull</name></member>
      <member refid="classiceberg_1_1Expressions_1a1a845a812dfed8e04455744195a49ba2" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotNull</name></member>
      <member refid="classiceberg_1_1Expressions_1acaed82242ca2977f607265a96fb3cf71" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotStartsWith</name></member>
      <member refid="classiceberg_1_1Expressions_1ac892e66726aa387b64fd92ec3a673a6b" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>NotStartsWith</name></member>
      <member refid="classiceberg_1_1Expressions_1ab6f02015ae774f2ee14bcb7dfba2c287" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Or</name></member>
      <member refid="classiceberg_1_1Expressions_1ad47578da5d288503fdd285375d7cde3d" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Predicate</name></member>
      <member refid="classiceberg_1_1Expressions_1a3b7ffc4fb5d0b3dbe19563c0ee78ed0c" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Predicate</name></member>
      <member refid="classiceberg_1_1Expressions_1ad8908c01193002b9cc1669955993f4b3" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Predicate</name></member>
      <member refid="classiceberg_1_1Expressions_1a6c13c818cb0b4c4c56a514f6de7be69c" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Predicate</name></member>
      <member refid="classiceberg_1_1Expressions_1ac3a394a408af6f3b6232d34dc49ba44b" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Predicate</name></member>
      <member refid="classiceberg_1_1Expressions_1a68da90fa97e43d93ba45511a0590ca41" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Predicate</name></member>
      <member refid="classiceberg_1_1Expressions_1a4f8e5d44cd26c0d7ed9306f53f147e2e" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Predicate</name></member>
      <member refid="classiceberg_1_1Expressions_1a482a0f9ec93ef525cd9cf47b78b36a40" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Ref</name></member>
      <member refid="classiceberg_1_1Expressions_1af8d953550427e80e5ec04179d194d141" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>StartsWith</name></member>
      <member refid="classiceberg_1_1Expressions_1adce99b57596ff49331159cad97c52cdf" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>StartsWith</name></member>
      <member refid="classiceberg_1_1Expressions_1a0c80fa9b7e8d7513e63696e8c0076a25" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Transform</name></member>
      <member refid="classiceberg_1_1Expressions_1aadbb6b60bcaad6043a65b90a78bff09b" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Truncate</name></member>
      <member refid="classiceberg_1_1Expressions_1a6066a65c379f703138e1b0abd8ed146d" prot="public" virt="non-virtual"><scope>iceberg::Expressions</scope><name>Year</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
