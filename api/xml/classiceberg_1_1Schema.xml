<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="classiceberg_1_1Schema" kind="class" language="C++" prot="public">
    <compoundname>iceberg::Schema</compoundname>
    <basecompoundref refid="classiceberg_1_1StructType" prot="public" virt="non-virtual">iceberg::StructType</basecompoundref>
    <includes refid="schema_8h" local="no">schema.h</includes>
    <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="classiceberg_1_1Schema_1a1274a5d2d95c7a6a34754f435b4d77c0" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>constexpr int32_t</type>
        <definition>constexpr int32_t iceberg::Schema::kInitialSchemaId</definition>
        <argsstring></argsstring>
        <name>kInitialSchemaId</name>
        <qualifiedname>iceberg::Schema::kInitialSchemaId</qualifiedname>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="48" column="28" bodyfile="iceberg/schema.h" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classiceberg_1_1Schema_1af73c881a3a7b8943d1566782f732f000" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>constexpr int32_t</type>
        <definition>constexpr int32_t iceberg::Schema::kInvalidColumnId</definition>
        <argsstring></argsstring>
        <name>kInvalidColumnId</name>
        <qualifiedname>iceberg::Schema::kInvalidColumnId</qualifiedname>
        <initializer>= -1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="49" column="28" bodyfile="iceberg/schema.h" bodystart="49" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classiceberg_1_1Schema_1a990dd1d3e220ee6862af791e177c1eef" prot="private" static="no" mutable="no">
        <type>const std::optional&lt; int32_t &gt;</type>
        <definition>const std::optional&lt;int32_t&gt; iceberg::Schema::schema_id_</definition>
        <argsstring></argsstring>
        <name>schema_id_</name>
        <qualifiedname>iceberg::Schema::schema_id_</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="110" column="23" bodyfile="iceberg/schema.h" bodystart="110" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classiceberg_1_1Schema_1a04bb5d845e28f4aba4b70a5999cd314e" prot="private" static="no" mutable="no">
        <type><ref refid="classiceberg_1_1Lazy" kindref="compound">Lazy</ref>&lt; InitIdToFieldMap &gt;</type>
        <definition>Lazy&lt;InitIdToFieldMap&gt; iceberg::Schema::id_to_field_</definition>
        <argsstring></argsstring>
        <name>id_to_field_</name>
        <qualifiedname>iceberg::Schema::id_to_field_</qualifiedname>
        <briefdescription>
<para>Mapping from field id to field. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="112" column="8" bodyfile="iceberg/schema.h" bodystart="112" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classiceberg_1_1Schema_1a90db642b1b7a3705ba64cfabce7fccc3" prot="private" static="no" mutable="no">
        <type><ref refid="classiceberg_1_1Lazy" kindref="compound">Lazy</ref>&lt; InitNameToIdMap &gt;</type>
        <definition>Lazy&lt;InitNameToIdMap&gt; iceberg::Schema::name_to_id_</definition>
        <argsstring></argsstring>
        <name>name_to_id_</name>
        <qualifiedname>iceberg::Schema::name_to_id_</qualifiedname>
        <briefdescription>
<para>Mapping from field name to field id. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="114" column="8" bodyfile="iceberg/schema.h" bodystart="114" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classiceberg_1_1Schema_1adb1e289f7509842516253483b6385d66" prot="private" static="no" mutable="no">
        <type><ref refid="classiceberg_1_1Lazy" kindref="compound">Lazy</ref>&lt; InitLowerCaseNameToIdMap &gt;</type>
        <definition>Lazy&lt;InitLowerCaseNameToIdMap&gt; iceberg::Schema::lowercase_name_to_id_</definition>
        <argsstring></argsstring>
        <name>lowercase_name_to_id_</name>
        <qualifiedname>iceberg::Schema::lowercase_name_to_id_</qualifiedname>
        <briefdescription>
<para>Mapping from lowercased field name to field id. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="116" column="8" bodyfile="iceberg/schema.h" bodystart="116" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classiceberg_1_1Schema_1aedf03ec1757792ee38451b37867d464e" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>iceberg::Schema::Schema</definition>
        <argsstring>(std::vector&lt; SchemaField &gt; fields, std::optional&lt; int32_t &gt; schema_id=std::nullopt)</argsstring>
        <name>Schema</name>
        <qualifiedname>iceberg::Schema::Schema</qualifiedname>
        <param>
          <type>std::vector&lt; <ref refid="classiceberg_1_1SchemaField" kindref="compound">SchemaField</ref> &gt;</type>
          <declname>fields</declname>
        </param>
        <param>
          <type>std::optional&lt; int32_t &gt;</type>
          <declname>schema_id</declname>
          <defval>std::nullopt</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="51" column="12" bodyfile="iceberg/schema.cc" bodystart="72" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Schema_1a0ccb24a394abbe00400f484a96c3ac5f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; int32_t &gt;</type>
        <definition>std::optional&lt; int32_t &gt; iceberg::Schema::schema_id</definition>
        <argsstring>() const</argsstring>
        <name>schema_id</name>
        <qualifiedname>iceberg::Schema::schema_id</qualifiedname>
        <briefdescription>
<para>Get the schema ID. </para>
        </briefdescription>
        <detaileddescription>
<para>A schema is identified by a unique ID for the purposes of schema evolution. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="58" column="17" bodyfile="iceberg/schema.cc" bodystart="75" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Schema_1a0dc4ba1d458b21509013a1b3ad388f09" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::string</type>
        <definition>std::string iceberg::Schema::ToString</definition>
        <argsstring>() const override</argsstring>
        <name>ToString</name>
        <qualifiedname>iceberg::Schema::ToString</qualifiedname>
        <reimplements refid="classiceberg_1_1util_1_1Formattable_1a79618aca5b3bf63610d9c87ac5ae0386">ToString</reimplements>
        <briefdescription>
<para>Get a user-readable string representation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="60" column="15" bodyfile="iceberg/schema.cc" bodystart="77" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Schema_1a4db920889e6f3fb26a17361e9e2c382c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>Result&lt; std::optional&lt; std::reference_wrapper&lt; const <ref refid="classiceberg_1_1SchemaField" kindref="compound">SchemaField</ref> &gt; &gt; &gt;</type>
        <definition>Result&lt; std::optional&lt; std::reference_wrapper&lt; const SchemaField &gt; &gt; &gt; iceberg::Schema::FindFieldByName</definition>
        <argsstring>(std::string_view name, bool case_sensitive=true) const</argsstring>
        <name>FindFieldByName</name>
        <qualifiedname>iceberg::Schema::FindFieldByName</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>case_sensitive</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Find the <ref refid="classiceberg_1_1SchemaField" kindref="compound">SchemaField</ref> by field name. </para>
        </briefdescription>
        <detaileddescription>
<para>Short names for maps and lists are included for any name that does not conflict with a canonical name. For example, a list, &apos;l&apos;, of structs with field &apos;x&apos; will produce short name &apos;l.x&apos; in addition to canonical name &apos;l.element.x&apos;. a map &apos;m&apos;, if its value include a structs with field &apos;x&apos; wil produce short name &apos;m.x&apos; in addition to canonical name &apos;m.value.x&apos; FIXME: Currently only handles ASCII lowercase conversion; extend to support non-ASCII characters (e.g., using std::towlower or ICU) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="71" column="10" bodyfile="iceberg/schema.cc" bodystart="90" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Schema_1a8ad01359cfbc11d0d018d30615cbdf1a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>Result&lt; std::optional&lt; std::reference_wrapper&lt; const <ref refid="classiceberg_1_1SchemaField" kindref="compound">SchemaField</ref> &gt; &gt; &gt;</type>
        <definition>Result&lt; std::optional&lt; std::reference_wrapper&lt; const SchemaField &gt; &gt; &gt; iceberg::Schema::FindFieldById</definition>
        <argsstring>(int32_t field_id) const</argsstring>
        <name>FindFieldById</name>
        <qualifiedname>iceberg::Schema::FindFieldById</qualifiedname>
        <param>
          <type>int32_t</type>
          <declname>field_id</declname>
        </param>
        <briefdescription>
<para>Find the <ref refid="classiceberg_1_1SchemaField" kindref="compound">SchemaField</ref> by field id. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="75" column="10" bodyfile="iceberg/schema.cc" bodystart="137" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Schema_1a1a2d0f2c8770c303e6fb59d0101d48cd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>Result&lt; std::unique_ptr&lt; <ref refid="classiceberg_1_1Schema" kindref="compound">Schema</ref> &gt; &gt;</type>
        <definition>Result&lt; std::unique_ptr&lt; Schema &gt; &gt; iceberg::Schema::Select</definition>
        <argsstring>(std::span&lt; const std::string &gt; names, bool case_sensitive=true) const</argsstring>
        <name>Select</name>
        <qualifiedname>iceberg::Schema::Select</qualifiedname>
        <param>
          <type>std::span&lt; const std::string &gt;</type>
          <declname>names</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>case_sensitive</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Creates a projected schema from selected field names. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>names</parametername>
</parameternamelist>
<parameterdescription>
<para>Selected field names and nested names are dot-concatenated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>case_sensitive</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether name matching is case-sensitive (default: true). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Projected schema containing only selected fields. </para>
</simplesect>
<simplesect kind="note"><para>If the field name of a nested type has been selected, all of its sub-fields will be selected. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="85" column="10" bodyfile="iceberg/schema.cc" bodystart="357" bodyend="387"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Schema_1a29b8bda082c94f3c5cbe7db451245ece" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>Result&lt; std::unique_ptr&lt; <ref refid="classiceberg_1_1Schema" kindref="compound">Schema</ref> &gt; &gt;</type>
        <definition>Result&lt; std::unique_ptr&lt; Schema &gt; &gt; iceberg::Schema::Project</definition>
        <argsstring>(const std::unordered_set&lt; int32_t &gt; &amp;field_ids) const</argsstring>
        <name>Project</name>
        <qualifiedname>iceberg::Schema::Project</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; int32_t &gt; &amp;</type>
          <declname>field_ids</declname>
        </param>
        <briefdescription>
<para>Creates a projected schema from selected field IDs. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>field_ids</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of field IDs to select </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Projected schema containing only the specified fields. </para>
</simplesect>
<simplesect kind="note"><para>Field ID of a nested field may not be projected unless at least one of its sub-fields has been projected. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="94" column="10" bodyfile="iceberg/schema.cc" bodystart="389" bodyend="405"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="friend">
      <memberdef kind="friend" id="classiceberg_1_1Schema_1adc6812cd69b9ba15f65777902a289262" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool operator==</definition>
        <argsstring>(const Schema &amp;lhs, const Schema &amp;rhs)</argsstring>
        <name>operator==</name>
        <qualifiedname>iceberg::Schema::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classiceberg_1_1Schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classiceberg_1_1Schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="97" column="15" bodyfile="iceberg/schema.h" bodystart="97" bodyend="97"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="classiceberg_1_1Schema_1a0648412bab1c8f5e956610d3c44c1078" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iceberg::Schema::Equals</definition>
        <argsstring>(const Schema &amp;other) const</argsstring>
        <name>Equals</name>
        <qualifiedname>iceberg::Schema::Equals</qualifiedname>
        <param>
          <type>const <ref refid="classiceberg_1_1Schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Compare two schemas for equality. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="101" column="8" bodyfile="iceberg/schema.cc" bodystart="86" bodyend="88"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-static-func">
      <memberdef kind="function" id="classiceberg_1_1Schema_1af73741b0f0ece0d308c30d01212bc4fb" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Result&lt; std::unordered_map&lt; int32_t, std::reference_wrapper&lt; const <ref refid="classiceberg_1_1SchemaField" kindref="compound">SchemaField</ref> &gt; &gt; &gt;</type>
        <definition>Result&lt; std::unordered_map&lt; int32_t, std::reference_wrapper&lt; const SchemaField &gt; &gt; &gt; iceberg::Schema::InitIdToFieldMap</definition>
        <argsstring>(const Schema &amp;)</argsstring>
        <name>InitIdToFieldMap</name>
        <qualifiedname>iceberg::Schema::InitIdToFieldMap</qualifiedname>
        <param>
          <type>const <ref refid="classiceberg_1_1Schema" kindref="compound">Schema</ref> &amp;</type>
          <defname>self</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="104" column="3" bodyfile="iceberg/schema.cc" bodystart="109" bodyend="114"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Schema_1a27aa1dfeadf99fe70fb7d10064c494b8" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Result&lt; std::unordered_map&lt; std::string, int32_t, <ref refid="structiceberg_1_1StringHash" kindref="compound">StringHash</ref>, std::equal_to&lt;&gt; &gt; &gt;</type>
        <definition>Result&lt; std::unordered_map&lt; std::string, int32_t, StringHash, std::equal_to&lt;&gt; &gt; &gt; iceberg::Schema::InitNameToIdMap</definition>
        <argsstring>(const Schema &amp;)</argsstring>
        <name>InitNameToIdMap</name>
        <qualifiedname>iceberg::Schema::InitNameToIdMap</qualifiedname>
        <param>
          <type>const <ref refid="classiceberg_1_1Schema" kindref="compound">Schema</ref> &amp;</type>
          <defname>self</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="106" column="3" bodyfile="iceberg/schema.cc" bodystart="117" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="classiceberg_1_1Schema_1a086e7f4807a77b116cf60b690a7060e7" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Result&lt; std::unordered_map&lt; std::string, int32_t, <ref refid="structiceberg_1_1StringHash" kindref="compound">StringHash</ref>, std::equal_to&lt;&gt; &gt; &gt;</type>
        <definition>Result&lt; std::unordered_map&lt; std::string, int32_t, StringHash, std::equal_to&lt;&gt; &gt; &gt; iceberg::Schema::InitLowerCaseNameToIdMap</definition>
        <argsstring>(const Schema &amp;)</argsstring>
        <name>InitLowerCaseNameToIdMap</name>
        <qualifiedname>iceberg::Schema::InitLowerCaseNameToIdMap</qualifiedname>
        <param>
          <type>const <ref refid="classiceberg_1_1Schema" kindref="compound">Schema</ref> &amp;</type>
          <defname>self</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iceberg/schema.h" line="108" column="3" bodyfile="iceberg/schema.cc" bodystart="127" bodyend="135"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>A schema for a <ref refid="classiceberg_1_1Table" kindref="compound">Table</ref>. </para>
    </briefdescription>
    <detaileddescription>
<para>A schema is a list of typed columns, along with a unique integer ID. A <ref refid="classiceberg_1_1Table" kindref="compound">Table</ref> may have different schemas over its lifetime due to schema evolution. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="3">
        <label>iceberg::NestedType</label>
        <link refid="classiceberg_1_1NestedType"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>iceberg::Schema</label>
        <link refid="classiceberg_1_1Schema"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>iceberg::StructType</label>
        <link refid="classiceberg_1_1StructType"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>iceberg::Type</label>
        <link refid="classiceberg_1_1Type"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>iceberg::util::Formattable</label>
        <link refid="classiceberg_1_1util_1_1Formattable"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="8">
        <label>iceberg::Lazy&lt; InitFieldById &gt;</label>
        <link refid="classiceberg_1_1Lazy"/>
      </node>
      <node id="10">
        <label>iceberg::Lazy&lt; InitFieldByLowerCaseName &gt;</label>
        <link refid="classiceberg_1_1Lazy"/>
      </node>
      <node id="9">
        <label>iceberg::Lazy&lt; InitFieldByName &gt;</label>
        <link refid="classiceberg_1_1Lazy"/>
      </node>
      <node id="3">
        <label>iceberg::NestedType</label>
        <link refid="classiceberg_1_1NestedType"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>iceberg::Schema</label>
        <link refid="classiceberg_1_1Schema"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="7">
        <label>iceberg::SchemaField</label>
        <link refid="classiceberg_1_1SchemaField"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>iceberg::StructType</label>
        <link refid="classiceberg_1_1StructType"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>fields_</edgelabel>
        </childnode>
        <childnode refid="8" relation="usage">
          <edgelabel>field_by_id_</edgelabel>
        </childnode>
        <childnode refid="9" relation="usage">
          <edgelabel>field_by_name_</edgelabel>
        </childnode>
        <childnode refid="10" relation="usage">
          <edgelabel>field_by_lowercase_name_</edgelabel>
        </childnode>
      </node>
      <node id="4">
        <label>iceberg::Type</label>
        <link refid="classiceberg_1_1Type"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>iceberg::util::Formattable</label>
        <link refid="classiceberg_1_1util_1_1Formattable"/>
      </node>
      <node id="6">
        <label>std::vector&lt; iceberg::SchemaField &gt;</label>
        <childnode refid="7" relation="usage">
          <edgelabel>elements</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="iceberg/schema.h" line="46" column="1" bodyfile="iceberg/schema.h" bodystart="46" bodyend="117"/>
    <listofallmembers>
      <member refid="classiceberg_1_1Schema_1a0648412bab1c8f5e956610d3c44c1078" prot="private" virt="non-virtual"><scope>iceberg::Schema</scope><name>Equals</name></member>
      <member refid="classiceberg_1_1StructType_1ac409fbe5fd9f8f37b398bb737795da7f" prot="protected" virt="virtual" ambiguityscope="iceberg::StructType::"><scope>iceberg::Schema</scope><name>Equals</name></member>
      <member refid="classiceberg_1_1StructType_1a5655beee2ab506fc7d3146d2946d26b2" prot="protected" virt="non-virtual"><scope>iceberg::Schema</scope><name>field_by_id_</name></member>
      <member refid="classiceberg_1_1StructType_1a085ae2da9c1b842d0c86eca458d8f431" prot="protected" virt="non-virtual"><scope>iceberg::Schema</scope><name>field_by_lowercase_name_</name></member>
      <member refid="classiceberg_1_1StructType_1aa77c6676945a053932ce5b799b979453" prot="protected" virt="non-virtual"><scope>iceberg::Schema</scope><name>field_by_name_</name></member>
      <member refid="classiceberg_1_1StructType_1a450d536bde2a559ac3781cd6c5ebc719" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>fields</name></member>
      <member refid="classiceberg_1_1StructType_1a327c88bf1366c1ff8df01ee92b55a8ca" prot="protected" virt="non-virtual"><scope>iceberg::Schema</scope><name>fields_</name></member>
      <member refid="classiceberg_1_1Schema_1a8ad01359cfbc11d0d018d30615cbdf1a" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>FindFieldById</name></member>
      <member refid="classiceberg_1_1Schema_1a4db920889e6f3fb26a17361e9e2c382c" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>FindFieldByName</name></member>
      <member refid="classiceberg_1_1StructType_1a29472346ff0ab4cd57b6bbebe2168d52" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>GetFieldById</name></member>
      <member refid="classiceberg_1_1StructType_1a6839caa3cd828fc09282e9cf4f6b69cd" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>GetFieldByIndex</name></member>
      <member refid="classiceberg_1_1StructType_1a3fd3403e743eba662f0ed50681e015b4" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>GetFieldByName</name></member>
      <member refid="classiceberg_1_1StructType_1a2213c2a9f6606cfc7276faac253d8753" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>GetFieldByName</name></member>
      <member refid="classiceberg_1_1StructType_1a4eaddf68ef7fbdf4ae44d3a67f1fc99d" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>GetFieldByName</name></member>
      <member refid="classiceberg_1_1Schema_1a04bb5d845e28f4aba4b70a5999cd314e" prot="private" virt="non-virtual"><scope>iceberg::Schema</scope><name>id_to_field_</name></member>
      <member refid="classiceberg_1_1StructType_1a18f9f394cb75a590d848dd3735c344a7" prot="protected" virt="non-virtual"><scope>iceberg::Schema</scope><name>InitFieldById</name></member>
      <member refid="classiceberg_1_1StructType_1ab476b47b25cbe844fa5299e5f5cf11d1" prot="protected" virt="non-virtual"><scope>iceberg::Schema</scope><name>InitFieldByLowerCaseName</name></member>
      <member refid="classiceberg_1_1StructType_1a4a88a995db7cf27e9b338137cac34d98" prot="protected" virt="non-virtual"><scope>iceberg::Schema</scope><name>InitFieldByName</name></member>
      <member refid="classiceberg_1_1Schema_1af73741b0f0ece0d308c30d01212bc4fb" prot="private" virt="non-virtual"><scope>iceberg::Schema</scope><name>InitIdToFieldMap</name></member>
      <member refid="classiceberg_1_1Schema_1a086e7f4807a77b116cf60b690a7060e7" prot="private" virt="non-virtual"><scope>iceberg::Schema</scope><name>InitLowerCaseNameToIdMap</name></member>
      <member refid="classiceberg_1_1Schema_1a27aa1dfeadf99fe70fb7d10064c494b8" prot="private" virt="non-virtual"><scope>iceberg::Schema</scope><name>InitNameToIdMap</name></member>
      <member refid="classiceberg_1_1NestedType_1ad658681f880385907591f637fb20f44b" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>is_nested</name></member>
      <member refid="classiceberg_1_1NestedType_1a973f9a2e897d90e2f7be02c953bc2246" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>is_primitive</name></member>
      <member refid="classiceberg_1_1Schema_1a1274a5d2d95c7a6a34754f435b4d77c0" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>kInitialSchemaId</name></member>
      <member refid="classiceberg_1_1Schema_1af73c881a3a7b8943d1566782f732f000" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>kInvalidColumnId</name></member>
      <member refid="classiceberg_1_1StructType_1a9ffc6c8564bbc187bef15933de34c3cd" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>kTypeId</name></member>
      <member refid="classiceberg_1_1Schema_1adb1e289f7509842516253483b6385d66" prot="private" virt="non-virtual"><scope>iceberg::Schema</scope><name>lowercase_name_to_id_</name></member>
      <member refid="classiceberg_1_1Schema_1a90db642b1b7a3705ba64cfabce7fccc3" prot="private" virt="non-virtual"><scope>iceberg::Schema</scope><name>name_to_id_</name></member>
      <member refid="classiceberg_1_1Schema_1adc6812cd69b9ba15f65777902a289262" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>operator==</name></member>
      <member refid="classiceberg_1_1Schema_1a29b8bda082c94f3c5cbe7db451245ece" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>Project</name></member>
      <member refid="classiceberg_1_1Schema_1aedf03ec1757792ee38451b37867d464e" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>Schema</name></member>
      <member refid="classiceberg_1_1Schema_1a0ccb24a394abbe00400f484a96c3ac5f" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>schema_id</name></member>
      <member refid="classiceberg_1_1Schema_1a990dd1d3e220ee6862af791e177c1eef" prot="private" virt="non-virtual"><scope>iceberg::Schema</scope><name>schema_id_</name></member>
      <member refid="classiceberg_1_1NestedType_1a2c000477a9f8bd01766fffc5aeefd309" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>SchemaFieldConstRef</name></member>
      <member refid="classiceberg_1_1Schema_1a1a2d0f2c8770c303e6fb59d0101d48cd" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>Select</name></member>
      <member refid="classiceberg_1_1StructType_1ae302f07109f0f1a519653e43fc745032" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>StructType</name></member>
      <member refid="classiceberg_1_1Schema_1a0dc4ba1d458b21509013a1b3ad388f09" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>ToString</name></member>
      <member refid="classiceberg_1_1StructType_1a1281cfc082575d9656a1e72ba07bdbd1" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>type_id</name></member>
      <member refid="classiceberg_1_1util_1_1Formattable_1acfe29264450018bab0ceab0828cf46f9" prot="public" virt="virtual"><scope>iceberg::Schema</scope><name>~Formattable</name></member>
      <member refid="classiceberg_1_1StructType_1ae3dde09c581bd05c344a44c29431184f" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>~StructType</name></member>
      <member refid="classiceberg_1_1Type_1a62b9070ee3fd1c5f8949a5785a414c6c" prot="public" virt="non-virtual"><scope>iceberg::Schema</scope><name>~Type</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
